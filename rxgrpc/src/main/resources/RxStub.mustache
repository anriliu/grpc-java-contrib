{{#packageName}}
package {{packageName}};
{{/packageName}}

import com.google.common.util.concurrent.Runnables;
import io.grpc.Channel;
import io.grpc.stub.StreamObserver;
import io.reactivex.*;

import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Function;

{{#deprecated}}@Deprecated{{/deprecated}}
@javax.annotation.Generated(
value = "by RxGrpc generator",
comments = "Source: {{protoName}}")
public final class {{className}} {
    private {{className}}() {}

    public static Rx{{serviceName}}Stub newRxStub(Channel channel) {
        return new Rx{{serviceName}}Stub(channel);
    }

    public static final class Rx{{serviceName}}Stub {
        private {{serviceName}}Grpc.{{serviceName}}Stub delegateStub;

        private Rx{{serviceName}}Stub(Channel channel) {
            delegateStub = {{serviceName}}Grpc.newStub(channel);
        }
        {{#oneToOne}}{{#deprecated}}@Deprecated{{/deprecated}}
        public Single<{{outputType}}> {{methodName}}(Single<{{inputType}}> rxRequest) {
            return oneToOne(rxRequest, delegateStub::{{methodName}});
        }
        {{/oneToOne}}
        {{#oneToMany}}{{#deprecated}}@Deprecated{{/deprecated}}
        public Observable<{{outputType}}> {{methodName}}(Single<{{inputType}}> rxRequest) {
            return oneToMany(rxRequest, delegateStub::{{methodName}});
        }
        {{/oneToMany}}
        {{#manyToOne}}{{#deprecated}}@Deprecated{{/deprecated}}
        public Single<{{outputType}}> {{methodName}}(Observable<{{inputType}}> rxRequest) {
            return manyToOne(rxRequest, delegateStub::{{methodName}});
        }
        {{/manyToOne}}
        {{#manyToMany}}{{#deprecated}}@Deprecated{{/deprecated}}
        public Observable<{{outputType}}> {{methodName}}(Observable<{{inputType}}> rxRequest) {
            return manyToMany(rxRequest, delegateStub::{{methodName}});
        }
        {{/manyToMany}}
    }

    public static abstract class {{serviceName}}ImplBase extends {{serviceName}}Grpc.{{serviceName}}ImplBase {
        {{#oneToOne}}{{#deprecated}}@Deprecated{{/deprecated}}
        public abstract Single<{{outputType}}> {{methodName}}(Single<{{inputType}}> request);

        @Override
        public void {{methodName}}(HelloRequest request, StreamObserver<{{outputType}}> responseObserver) {
            oneToOne(request, responseObserver, this::{{methodName}});
        }
        {{/oneToOne}}
        {{#oneToMany}}{{#deprecated}}@Deprecated{{/deprecated}}
        public abstract Observable<{{outputType}}> {{methodName}}(Single<{{inputType}}> request);

        @Override
        public void {{methodName}}(HelloRequest request, StreamObserver<{{outputType}}> responseObserver) {
            oneToMany(request, responseObserver, this::{{methodName}});
        }
        {{/oneToMany}}
        {{#manyToOne}}{{#deprecated}}@Deprecated{{/deprecated}}
        public abstract Single<{{outputType}}> {{methodName}}(Observable<{{inputType}}> request);

        @Override
        public StreamObserver<{{inputType}}> {{methodName}}(StreamObserver<{{outputType}}> responseObserver) {
            return manyToOne(responseObserver, this::{{methodName}});
        }
        {{/manyToOne}}
        {{#manyToMany}}{{#deprecated}}@Deprecated{{/deprecated}}
        public abstract Observable<{{outputType}}> {{methodName}}(Observable<{{inputType}}> request);

        @Override
        public StreamObserver<{{inputType}}> {{methodName}}(StreamObserver<{{outputType}}> responseObserver) {
            return manyToMany(responseObserver, this::{{methodName}});
        }
        {{/manyToMany}}
    }

    private static <TRequest, TResponse> Single<TResponse> oneToOne(
            Single<TRequest> rxRequest,
            BiConsumer<TRequest, StreamObserver<TResponse>> delegate) {
        try {
            return Single.create(emitter -> rxRequest.subscribe(
                    request -> delegate.accept(request, new RxStreamObserver<TResponse>(emitter)),
                    emitter::onError
            ));
        } catch (Throwable throwable) {
            return Single.error(throwable);
        }
    }

    private static <TRequest, TResponse> void oneToOne(
            TRequest request, StreamObserver<TResponse> responseObserver,
            Function<Single<TRequest>, Single<TResponse>> delegate) {
        try {
            Single<TRequest> rxRequest = Single.just(request);

            Single<TResponse> rxResponse = delegate.apply(rxRequest);
            rxResponse.subscribe(
                    responseObserver::onNext,
                    responseObserver::onError);
            responseObserver.onCompleted();
        } catch (Throwable throwable) {
            responseObserver.onError(throwable);
        }
    }

    private static <TRequest, TResponse> Observable<TResponse> oneToMany(
            Single<TRequest> rxRequest,
            BiConsumer<TRequest, StreamObserver<TResponse>> delegate) {
        try {
            return Observable.create(emitter -> rxRequest.subscribe(
                    request -> delegate.accept(request, new RxStreamObserver<TResponse>(emitter)),
                    emitter::onError
            ));
        } catch (Throwable throwable) {
            return Observable.error(throwable);
        }
    }

    private static <TRequest, TResponse> void oneToMany(
            TRequest request, StreamObserver<TResponse> responseObserver,
            Function<Single<TRequest>, Observable<TResponse>> delegate) {
        try {
            Single<TRequest> rxRequest = Single.just(request);

            Observable<TResponse> rxResponse = delegate.apply(rxRequest);
            rxResponse.subscribe(
                    responseObserver::onNext,
                    responseObserver::onError,
                    responseObserver::onCompleted);
        } catch (Throwable throwable) {
            responseObserver.onError(throwable);
        }
    }

    private static <TRequest, TResponse> Single<TResponse> manyToOne(
            Observable<TRequest> rxRequest,
            Function<StreamObserver<TResponse>, StreamObserver<TRequest>> delegate) {
        try {
            return Single.create(emitter -> {
                StreamObserver<TRequest> reqStream = delegate.apply(new RxStreamObserver<>(emitter));
                rxRequest.subscribe(reqStream::onNext, reqStream::onError, reqStream::onCompleted);
            });
        } catch (Throwable throwable) {
            return Single.error(throwable);
        }
    }

    private static <TRequest, TResponse> StreamObserver<TRequest> manyToOne(
            StreamObserver<TResponse> responseObserver,
            Function<Observable<TRequest>, Single<TResponse>> delegate) {
        ObservableBridgeEmitter<TRequest> requestEmitter = new ObservableBridgeEmitter<>();

        try {
            Single<TResponse> rxResponse = delegate.apply(Observable.create(requestEmitter));
            rxResponse.subscribe(value -> {
                        responseObserver.onNext(value);
                        responseObserver.onCompleted();
                    },
                    responseObserver::onError);
        } catch (Throwable throwable) {
            responseObserver.onError(throwable);
        }

        return new RxStreamObserver<>(requestEmitter);
    }

    private static <TRequest, TResponse> Observable<TResponse> manyToMany(
            Observable<TRequest> rxRequest,
            Function<StreamObserver<TResponse>, StreamObserver<TRequest>> delegate) {
        try {
            return Observable.create(emitter -> {
                StreamObserver<TRequest> reqStream = delegate.apply(new RxStreamObserver<>(emitter));
                rxRequest.subscribe(reqStream::onNext, reqStream::onError, reqStream::onCompleted);
            });
        } catch (Throwable throwable) {
            return Observable.error(throwable);
        }
    }

    private static <TRequest, TResponse> StreamObserver<TRequest> manyToMany(
            StreamObserver<TResponse> responseObserver,
            Function<Observable<TRequest>, Observable<TResponse>> delegate) {
        ObservableBridgeEmitter<TRequest> requestEmitter = new ObservableBridgeEmitter<>();

        try {
            Observable<TResponse> rxResponse = delegate.apply(Observable.create(requestEmitter));
            rxResponse.subscribe(responseObserver::onNext, responseObserver::onError, responseObserver::onCompleted);
        } catch (Throwable throwable) {
            responseObserver.onError(throwable);
        }

        return new RxStreamObserver<>(requestEmitter);
    }

    private static class RxStreamObserver<V> implements StreamObserver<V> {
        private Consumer<V> onNext;
        private Consumer<Throwable> onError;
        private Runnable onCompleted;

        private RxStreamObserver(Emitter<V> requestEmitter) {
            this(requestEmitter::onNext, requestEmitter::onError, requestEmitter::onComplete);
        }

        private RxStreamObserver(SingleEmitter<V> requestEmitter) {
            this(requestEmitter::onSuccess, requestEmitter::onError, Runnables.doNothing());
        }

        private RxStreamObserver(Consumer<V> onNext, Consumer<Throwable> onError, Runnable onCompleted) {
            this.onNext = onNext;
            this.onError = onError;
            this.onCompleted = onCompleted;
        }

        @Override
        public void onNext(V value) {
            onNext.accept(value);
        }

        @Override
        public void onError(Throwable t) {
            onError.accept(t);
        }

        @Override
        public void onCompleted() {
            onCompleted.run();
        }
    }

    private static class ObservableBridgeEmitter<T> implements ObservableOnSubscribe<T>, Emitter<T> {
        private ObservableEmitter<T> observableEmitter;

        @Override
        public void subscribe(ObservableEmitter<T> ObservableEmitter) throws Exception {
            this.observableEmitter = ObservableEmitter;
        }

        @Override
        public void onNext(T t) {
            observableEmitter.onNext(t);
        }

        @Override
        public void onError(Throwable throwable) {
            observableEmitter.onError(throwable);
        }

        @Override
        public void onComplete() {
            observableEmitter.onComplete();
        }
    }
}

